# 一、哈希表、映射、集合的实现与特性

## 1. 哈希表 Hash table

### 1.1. 概述
> **哈希表**（Hash table,也叫作散列表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做 **散列函数** ，存放记录的数组称做 **散列表**。

### 1.2. Hash Function 散列函数（哈希函数）
> 若关键字为 *k* ，则其值存放在 *f(k)* 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 *f* 为 **散列函数**


### 1.3. Hash Collisions 哈希碰撞
> 对不同的关键字可能得到同一散列地址，即 *k1 != k2* ，而 *f(k1) == f(k2)* ，这种现象称为冲突（英语：Collision）。

* 如何处理哈希冲突
	* 拉链式解决冲突法（增加一个维度）

### 1.4. 复杂度分析
* 时间复杂度 Search/Insertion/Deletion
	* Average: O(1)
	* Worst: O(n)
* 空间复杂度: O(n)

### 1.5. 应用

#### 1.5.1. HashMap

key-value对，key不重复

* 成员变量
	* table: 存储元素的数组
	* capacity: 当前最多可以装多少元素 （默认为16 -> 2的幂）
	* size: 当前已经装了多少元素
	* loadFactor: 加载因子，表示HashMap满的程度（默认0.75 -> 3/4 与capacity乘积为整数 & 空间 < 0.75 < 效率）
	* threshold = capacity * loadFactor: 元素个数超过threshold时触发扩容  
* API
	* V put(K key, V value)
		> 存储 *key-value* 键值对。若 *key* 存在，返回旧的 *value* 值（可以为 *null*），否则返回 *null*。

		> 1. 计算 *key* 的hash值
		> 2. 若未初始化则 初始化 *table*
		> 3. 根据hash值找到数组下标
			* 若该位置未存储元素：直接存储元素即可
			* 若该位置已有元素：
				* key 已存在，覆盖 oldValue
				* key 不存在，元素插入到链表尾部
					* 链表长度大于等于8时，转为红黑树
					* 元素总个数达到 *threshold*，进行扩容
		
	* V get(Object key)
		> 返回 *key* 对应的 *value* 值。若 *key* 不存在则返回 *null* 。

		> 1. 计算 *key* 的hash值
		> 2. 根据hash值定位数组table下标，取出元素比较 *key*
		> 3. 若 *key* 不相等，则遍历链表（也有可能是红黑树）

#### 1.5.2. Set
元素不重复的集合

### 1.6. 工程实践
* 电话簿
* 用户信息表
* 缓存（LRU Cache）
* 键值对存储（Redis）

# 二、树、二叉树、二叉搜索树

## 1. 树 Tree

### 1.1. 概述
> 树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

### 1.2. 特点
* 每个节点都只有有限个子节点或无子节点
* 没有父节点的节点称为根节点
* 每一个非根节点有且只有一个父节点
* 除了根节点外，每个子节点可以分为多个不相交的子树
* 树里面没有环路(cycle)

## 2. 二叉树 Binary Tree

### 2.1. 概述
> 二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。

### 2.2. 遍历

1. 前序（Pre-order）：根-左-右
2. 中序（In-order）：左-根-右
3. 后序（Post-order）：左-右-根

### 2.3. 存储（数组）
* 若某个节点索引为 i
	* 根节点索引：0
	* 父节点（如果有）索引：(i-1)/2
	* 左子节点索引：2i + 1
	* 右子节点索引：2i + 2
* 优点
	* 紧凑存储
	* 更好的访问
* 缺点
	* 需要连续的存储空间
	* 空间浪费（每个节点都只有右孩子：树高h,占用空间2^h - 1,实际节点h） 

### 2.4. 分类

* 满二叉树（Full Tree）
	* 每一层上的节点数都是最大节点数
	* 总节点: k = 2^h - 1
	* 树高：h = log2(k + 1)
* 完全二叉树 (Complete Tree)
	* 除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点
	* 总节点： 2^(h-1) <= k <= 2^h - 1 

## 3. 图 Graph
### 3.1. 图的属性
* Graph(V, E)
	* V - vertex：点
		1. 度 - 入度和出度：点连了多少个边
		2. 点与点之间：连通与否
	* E - edge：边
		1. 有向和无向
		2. 权重（边长）

### 3.2. 表示和分类
* 表示方法
	* 邻接矩阵
	* 邻接表

* Tree是特殊化的Graph（没有环）
* LinkedList 是特殊化的Tree（一脉单传）

## 4. 二叉搜索树 Binary Search Tree

### 4.1. 概述
> 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：
> 	
> * 若任意节点的左子树不空，则左子树上**所有节点**的值均小于它的根节点的值
> * 若任意节点的右子树不空，则右子树上**所有节点**的值均大于或等于它的根节点的值
> * 任意节点的左、右子树也分别为二叉查找树

### 4.2. 常见操作
* 查找
> 在二叉搜索树b中查找x的过程为: 

	1. 若b是空树，则搜索失败，否则：
	2. 若x等于b的根节点的数据域之值，则查找成功；否则：
	3. 若x小于b的根节点的数据域之值，则搜索左子树；否则：
	4. 查找右子树。

* 插入
> 向一个二叉搜索树b中插入一个节点s的算法，过程为：

	1. 若b是空树，则将s所指节点作为根节点插入，否则：
	2. 若s->data等于b的根节点的数据域之值，则返回，否则：
	3. 若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
	4. 把s所指节点插入到右子树中。（新插入节点总是叶子节点）

* 删除
> 在二叉查找树删去一个结点，分三种情况讨论：

	1. 若p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。只需修改其双亲结点的指针即可。
	2. 若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可。
	3. 若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：
		1. 其一是令p的左子树为f的左/右（依p是f的左子树还是右子树而定）子树，s为p左子树的最右下的结点，而p的右子树为s的右子树；
		2. 其二是令p的直接前驱或直接后继替代p，然后再从二叉查找树中删去它的直接前驱（或直接后继）。

### 4.3. 复杂度分析
* 时间复杂度 Search/Insertion/Deletion
	* Average: O(log(n))
	* Worst: O(n)
* 空间复杂度: O(n)

# 三、堆、二叉堆

## 1. 堆 Heap

### 1.1. 概述
> 给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值。
### 1.2. 特性
* 任意节点小于（或大于）它的所有后裔，最小元（或最大元）在堆的根上（堆序性）。
* 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。

将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

## 2. 二叉堆 Binary Heap

### 2.1. 实现
二叉堆一般通过数组来实现。

* 根节点索引是：0
* 索引为i的左孩子的索引是：2*i + 1
* 索引为i的右孩子的索引是：2*i + 2
* 索引为i的父节点的索引是：floor((i-1)/2)  

### 2.2. 操作
* 插入 O(log(n))
	1. 新元素一律先插入到堆的尾部
	2. 依次向上调整整个堆的结构（一直到根）HeapifyUp
* 删除根节点
	1. 将堆尾元素替换到顶部
	2. 依次向下调整整个堆的结构（一直到尾）HeapifyDown